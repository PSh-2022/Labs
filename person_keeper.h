#ifndef PERSON_KEEPER_H
#define PERSON_KEEPER_H
#include "person.h"
#include "Stack.h"
#include <fstream>
/*паттерн singleton
-порождающий паттерн (для создания объектов без внесения
в программу лишних зависимостей).
-гарантирует, что у класса есть только один экземпляр, и предоставляет к нему
глобальную точку доступа.
-Применяется когда
1. В программе должен быть единственный экземпляр какого-то класса,
доступный всем клиентам.
2. Необходимо иметь больше контроля над глобальными переменными.
В отличие от глобальных переменных, паттерн Одиночка гарантирует, что
никакой другой код не заменит созданный экземпляр класса, поэтому вы
всегда уверены в наличии лишь одного объекта-одиночки.*/
/*здесь - расширенный singleton Майерса(1995)*/
/*развитие паттерна - https://habr.com/ru/post/147373/
https://www.cs.up.ac.za/cs/lmarshall/TDP/Notes/_Chapter28_Singleton.pdf*/
//с помощью паттерна предоставляем доступ к общему ресурсу - стеку ФИО
class PersonKeeper
{
    PersonKeeper()= default;//Шаг 4: конструктор, приватный
    ~PersonKeeper()= default;// деструктор, приватный
    PersonKeeper(const PersonKeeper&)=delete;//закрываем конструктор копирования
    PersonKeeper& operator=(const PersonKeeper&)=delete;//и оператор присваивания тоже закрываем
//стандарт языка С++11
//функция спецификатора delete - явное ограничение доступа к специальным методам класса(конструкторам, деструкторам, конструкторам перемещения, операторам присваивания и т. п.)
//функция спецификатора default - указать тот метод класса, который компилятору предписывается использовать по умолчанию(конструктор класса, который объявляется без параметров)
public:
   /* Одиночка скрывает от клиентов все способы создания нового объекта, кроме
    специального метода. Этот метод либо создаёт объект, либо отдаёт
    существующий объект, если он уже был создан.(в нашем случае создает объект)*/
    static PersonKeeper& instance(){
        // согласно стандарту, этот код ленивый и потокобезопасный
        //Шаг 3: ленивая инициализация - создание объекта при первом вызове метода
        //Потоковая безопасность — концепция программирования, применимая к многопоточным программам. Код потокобезопасен, если он функционирует исправно при использовании его из нескольких потоков одновременно.
        //Поток выполнения — наименьшая единица обработки, исполнение которой может быть назначено ядром операционной системы.
        static PersonKeeper keeper;//Шаг 1: Локальная статическая переменная в функции будет вызвана тогда и только тогда, когда будет вызвана сама функция
        return keeper;
    }; //Шаг 2: статическая создающий метод. Используется для получения одиночки
    //Person - тип значения узла в стеке
    Stack<Person> readPersons(std::fstream& file); // ФИО из файла в стек
    void writePersons(Stack<Person> s, std::fstream& file); // ФИО из стека в файл
};
/*статический метод в классе используется, когда необходимо
реализовать некоторое действие, которое относится к классу в
целом, а не к конкретному объекту класса.*/
/*Статическая переменная (или «переменная со статической продолжительностью жизни») сохраняет свое значение
 * даже после выхода из блока, в котором она определена. То есть она создается (и инициализируется) только один раз,
 *  а затем сохраняется на протяжении выполнения всей программы.*/
/*Статический метод или член класса означает, что он один и тот же на
все экземпляры (объекты) класса.
Статический член класса - это свойство, относящееся к классу в
целом, а не конкретному объекту.
• Статический член класса инициализируется вне класса, для того
чтобы была выделенная память компилятором в глобальном участке.
• static метод класса не имеет доступа к нестатическим членам
класса , так как у него нет указателя this. Для организации
работы с объектом, можно передать указатель на экземпляр класса.
• Статический член класс /метод класс можно использовать и без
создания экземпляра класса*/
#endif // PERSON_KEEPER_H
